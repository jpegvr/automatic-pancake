<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale Clone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents scrolling on mobile */
        }
        .font-bangers {
            font-family: 'Bangers', cursive;
        }
        #game-board {
            background-color: #4CAF50; /* Grassy field */
            background-image:
                linear-gradient(to right, rgba(0,0,0,0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0,0,0,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            position: relative;
            overflow: hidden;
            border: 4px solid #8B4513; /* Wooden border */
        }
        .bridge {
            background-color: #DAA520; /* Wooden plank color */
            border: 2px solid #8B4513;
            z-index: 1;
        }
        .river {
            background: linear-gradient(to right, #4682B4, #87CEEB); /* Steel Blue to Sky Blue */
            z-index: 0;
        }
        .tower {
            background-color: #A9A9A9; /* Stone color */
            border: 3px solid #696969;
            border-radius: 50% 50% 10% 10% / 20% 20% 10% 10%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            position: absolute;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .king-tower::before {
            content: 'üëë';
            font-size: 1.5rem; /* 24px */
        }
        .princess-tower::before {
             content: 'üèπ';
            font-size: 1.25rem; /* 20px */
        }
        .building {
            background-color: #DEB887; /* BurlyWood */
            border: 3px solid #8B4513;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            position: absolute;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-size: 2rem;
        }

        .troop {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem; /* 20px */
            transition: transform 0.1s linear, top 0.1s linear, left 0.1s linear;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .health-bar {
            position: absolute;
            bottom: -8px;
            width: 80%;
            height: 5px;
            background-color: #E0E0E0;
            border-radius: 2.5px;
            overflow: hidden;
        }
        .health-bar-inner {
            height: 100%;
            background-color: #4CAF50; /* Green health */
            border-radius: 2.5px;
            transition: width 0.2s;
        }
        .projectile {
            position: absolute;
            background-color: #FFD700;
            border-radius: 50%;
            width: 10px;
            height: 10px;
            z-index: 50;
            box-shadow: 0 0 5px #FFD700;
        }
        #elixir-bar-fill {
            transition: width 0.5s linear;
        }
        .card {
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }
        .card.selected {
            transform: translateY(-15px) scale(1.1);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.9);
        }
        .card.disabled {
            filter: grayscale(100%);
            cursor: not-allowed;
        }

        /* Message Modal */
        #message-modal {
            transition: opacity 0.3s ease-in-out;
        }
        #message-box {
            animation: slide-in 0.5s forwards;
        }
        @keyframes slide-in {
            0% { transform: translateY(-100px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body class="bg-gray-800 flex flex-col items-center justify-center min-h-screen p-4 text-white">

    <h1 class="text-4xl md:text-6xl font-bangers text-yellow-400 mb-4 tracking-wider">TOWER DUEL</h1>

    <div class="w-full max-w-sm md:max-w-md lg:max-w-lg aspect-[9/16] relative">
        <!-- Game Board -->
        <div id="game-board" class="w-full h-full rounded-lg shadow-2xl">
            <!-- River -->
            <div class="river absolute w-full h-1/12 top-1/2 -translate-y-1/2"></div>
            <!-- Bridges -->
            <div class="bridge absolute w-1/5 h-1/12 left-1/6 top-1/2 -translate-y-1/2 rounded"></div>
            <div class="bridge absolute w-1/5 h-1/12 right-1/6 top-1/2 -translate-y-1/2 rounded"></div>
        </div>

        <!-- Game Info Overlays -->
        <div class="absolute top-2 left-2 text-lg font-bold bg-black bg-opacity-50 px-2 py-1 rounded">
            AI: <span id="ai-towers">3</span>
        </div>
         <div class="absolute top-2 right-2 text-lg font-bold bg-black bg-opacity-50 px-2 py-1 rounded">
            Time: <span id="timer">180</span>s
        </div>
         <div class="absolute bottom-2 left-2 text-lg font-bold bg-black bg-opacity-50 px-2 py-1 rounded">
            You: <span id="player-towers">3</span>
        </div>
    </div>


    <!-- Player Hand & Elixir -->
    <div class="w-full max-w-sm md:max-w-md lg:max-w-lg mt-4">
        <!-- Elixir Bar -->
        <div class="w-full bg-gray-600 rounded-full h-6 border-2 border-purple-400 mb-2">
            <div id="elixir-bar-fill" class="bg-purple-600 h-full rounded-full" style="width: 30%;"></div>
            <div class="relative -top-6 w-full h-full flex items-center justify-center">
                <span id="elixir-count" class="font-bold text-lg">3</span> / 10
            </div>
        </div>

        <!-- Cards -->
        <div id="card-hand" class="grid grid-cols-4 gap-2">
            <!-- Cards will be dynamically inserted here -->
        </div>
    </div>
    
    <!-- Message Modal -->
    <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div id="message-box" class="bg-gray-700 p-8 rounded-lg shadow-2xl text-center border-4 border-yellow-400">
            <h2 id="message-title" class="text-4xl font-bangers text-yellow-400 mb-4"></h2>
            <p id="message-text" class="mb-6 text-lg"></p>
            <button id="restart-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-xl font-bangers tracking-wider">Play Again</button>
        </div>
    </div>

    <!-- Deck Builder Modal -->
    <div id="deck-builder-modal" class="fixed inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-50 p-4">
        <div class="bg-gray-700 p-6 rounded-lg shadow-2xl w-full max-w-2xl border-4 border-yellow-400">
            <h2 class="text-3xl font-bangers text-yellow-400 mb-4 text-center">Build Your Deck</h2>
            
            <h3 class="font-bold text-lg mb-2 text-purple-300">Your Deck (<span id="deck-count">0</span>/8)</h3>
            <div id="current-deck" class="grid grid-cols-4 sm:grid-cols-8 gap-2 bg-gray-800 p-2 rounded-md min-h-[120px] mb-4 border-2 border-gray-600">
                <!-- Selected cards go here -->
            </div>

            <h3 class="font-bold text-lg mb-2 text-green-300">Card Collection</h3>
            <div id="card-collection" class="grid grid-cols-4 sm:grid-cols-6 gap-2 bg-gray-800 p-2 rounded-md max-h-[300px] overflow-y-auto">
                <!-- All available cards go here -->
            </div>

            <button id="start-battle-button" class="mt-6 w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-xl font-bangers tracking-wider disabled:bg-gray-500 disabled:cursor-not-allowed">Start Battle</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameBoard = document.getElementById('game-board');
            const elixirBarFill = document.getElementById('elixir-bar-fill');
            const elixirCountEl = document.getElementById('elixir-count');
            const cardHandEl = document.getElementById('card-hand');
            const timerEl = document.getElementById('timer');
            const playerTowersEl = document.getElementById('player-towers');
            const aiTowersEl = document.getElementById('ai-towers');
            
            // Modal elements
            const messageModal = document.getElementById('message-modal');
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const restartButton = document.getElementById('restart-button');

            // Deck builder elements
            const deckBuilderModal = document.getElementById('deck-builder-modal');
            const currentDeckEl = document.getElementById('current-deck');
            const cardCollectionEl = document.getElementById('card-collection');
            const startBattleButton = document.getElementById('start-battle-button');
            const deckCountEl = document.getElementById('deck-count');

            // Game state
            let elixir = 5;
            let aiElixir = 5;
            let maxElixir = 10;
            let selectedTroop = null;
            let gameLoopInterval = null;
            let timerInterval = null;
            let elixirInterval = null;
            let aiInterval = null;
            let gameTime = 180;
            let gameObjects = []; // To store all troops, towers, projectiles
            let nextId = 0;
            const DECK_SIZE = 8;
            const HAND_SIZE = 4;

            const CARD_DATA = {
                // Troops
                knight: { cardType: 'troop', name: 'Knight', emoji: '‚öîÔ∏è', cost: 3, hp: 155, damage: 20, range: 1.5, speed: 1.2, type: 'ground', attackSpeed: 1200 },
                archer: { cardType: 'troop', name: 'Archer', emoji: 'üèπ', cost: 3, hp: 65, damage: 13, range: 5, speed: 1.2, type: 'ground', attackSpeed: 1000 },
                giant: { cardType: 'troop', name: 'Giant', emoji: 'üóø', cost: 5, hp: 500, damage: 28, range: 1.5, speed: 0.8, type: 'ground', targets: 'buildings', attackSpeed: 1700 },
                dragon: { cardType: 'troop', name: 'Dragon', emoji: 'üêâ', cost: 4, hp: 160, damage: 28, range: 4, speed: 1.4, type: 'air', attackSpeed: 1600, splashDamage: true, splashRadius: 10 },
                pekka: { cardType: 'troop', name: 'P.E.K.K.A', emoji: 'ü§ñ', cost: 7, hp: 650, damage: 120, range: 1.6, speed: 0.7, type: 'ground', attackSpeed: 1900 },
                wizard: { cardType: 'troop', name: 'Wizard', emoji: 'üßô', cost: 5, hp: 110, damage: 45, range: 5.5, speed: 1.1, type: 'ground', attackSpeed: 1600, splashDamage: true, splashRadius: 15 },
                golem: { cardType: 'troop', name: 'Golem', emoji: 'ü™®', cost: 8, hp: 850, damage: 40, range: 1.5, speed: 0.6, type: 'ground', targets: 'buildings', attackSpeed: 2500 },
                minions: { cardType: 'troop', name: 'Minions', emoji: 'ü¶á', cost: 3, hp: 48, damage: 16, range: 2.5, speed: 1.8, type: 'air', spawnCount: 3, spawnRadius: 15, attackSpeed: 1000 },
                hogRider: { cardType: 'troop', name: 'Hog Rider', emoji: 'üêó', cost: 4, hp: 220, damage: 45, range: 1.5, speed: 2.2, type: 'ground', targets: 'buildings', attackSpeed: 1600 },
                musketeer: { cardType: 'troop', name: 'Musketeer', emoji: 'üíÇ‚Äç‚ôÄÔ∏è', cost: 4, hp: 120, damage: 40, range: 6, speed: 1.1, type: 'ground', attackSpeed: 1200 },
                valkyrie: { cardType: 'troop', name: 'Valkyrie', emoji: 'üë©‚Äçü¶∞', cost: 4, hp: 190, damage: 32, range: 1.5, speed: 1.3, type: 'ground', attackSpeed: 1500, attackType: 'melee-splash' }, 
                goblins: { cardType: 'troop', name: 'Goblins', emoji: 'üë∫', cost: 2, hp: 38, damage: 13, range: 1.5, speed: 2.0, type: 'ground', spawnCount: 3, spawnRadius: 10, attackSpeed: 1100 },
                skeletons: { cardType: 'troop', name: 'Skeletons', emoji: 'üíÄ', cost: 1, hp: 16, damage: 6, range: 1.5, speed: 1.9, type: 'ground', spawnCount: 4, spawnRadius: 10, attackSpeed: 1000 },
                spearGoblins: { cardType: 'troop', name: 'Spear Goblins', emoji: 'üî±', cost: 2, hp: 28, damage: 9, range: 5, speed: 2.0, type: 'ground', spawnCount: 3, spawnRadius: 10, attackSpeed: 1200 },
                bomber: { cardType: 'troop', name: 'Bomber', emoji: 'üí£', cost: 2, hp: 45, damage: 30, range: 4.5, speed: 1.2, type: 'ground', attackSpeed: 1800, splashDamage: true, splashRadius: 12 },
                miniPekka: { cardType: 'troop', name: 'Mini P.E.K.K.A', emoji: '‚öôÔ∏è', cost: 4, hp: 300, damage: 90, range: 1.5, speed: 1.5, type: 'ground', attackSpeed: 1700 },
                prince: { cardType: 'troop', name: 'Prince', emoji: 'üê¥', cost: 5, hp: 320, damage: 65, range: 1.6, speed: 1.7, type: 'ground', attackSpeed: 1500, canCharge: true },
                eliteBarbarians: { cardType: 'troop', name: 'Elite Barbarians', emoji: 'üí™', cost: 6, hp: 220, damage: 42, range: 1.5, speed: 2.1, type: 'ground', spawnCount: 2, spawnRadius: 5, attackSpeed: 1500 },
                royalGiant: { cardType: 'troop', name: 'Royal Giant', emoji: 'üëë', cost: 6, hp: 550, damage: 35, range: 6.0, speed: 0.7, type: 'ground', targets: 'buildings', attackSpeed: 1800 },
                megaMinion: { cardType: 'troop', name: 'Mega Minion', emoji: 'üëø', cost: 3, hp: 130, damage: 35, range: 2.5, speed: 1.4, type: 'air', attackSpeed: 1500 },
                iceGolem: { cardType: 'troop', name: 'Ice Golem', emoji: 'üßä', cost: 2, hp: 280, damage: 10, range: 1.5, speed: 0.9, type: 'ground', targets: 'buildings', attackSpeed: 2500 },
                dartGoblin: { cardType: 'troop', name: 'Dart Goblin', emoji: 'üéØ', cost: 3, hp: 55, damage: 11, range: 6.5, speed: 2.0, type: 'ground', attackSpeed: 700 },
                witch: { cardType: 'troop', name: 'Witch', emoji: 'üßπ', cost: 5, hp: 130, damage: 18, range: 5, speed: 1.1, type: 'ground', attackSpeed: 1100, splashDamage: true, splashRadius: 8, spawnId: 'skeletons', spawnSpeed: 7000 },
                electroWizard: { cardType: 'troop', name: 'E. Wizard', emoji: '‚ö°Ô∏èüßô', cost: 4, hp: 110, damage: 18, range: 5, speed: 1.2, type: 'ground', attackSpeed: 1800, stunDuration: 500 },
                goblinGang: { cardType: 'troop', name: 'Goblin Gang', emoji: ' Gang ', cost: 3, spawnIds: [{id: 'goblins', count: 2}, {id: 'spearGoblins', count: 2}], type: 'ground' },

                // Spells
                fireball: { cardType: 'spell', name: 'Fireball', emoji: 'üî•', cost: 4, damage: 70, radius: 15 },
                arrows: { cardType: 'spell', name: 'Arrows', emoji: 'üéØ', cost: 3, damage: 35, radius: 25 },
                zap: { cardType: 'spell', name: 'Zap', emoji: '‚ö°Ô∏è', cost: 2, damage: 25, radius: 12, stunDuration: 500 },
                rage: { cardType: 'spell', name: 'Rage', emoji: 'üò°', cost: 2, radius: 20, duration: 6000, speedBoost: 1.35, attackSpeedBoost: 1.35 },
                freeze: { cardType: 'spell', name: 'Freeze', emoji: 'ü•∂', cost: 4, radius: 20, duration: 3500 },
                theLog: { cardType: 'spell', name: 'The Log', emoji: 'üå≤', cost: 2, damage: 30, width: 20, type: 'groundOnly' },

                // Buildings
                cannon: { cardType: 'building', name: 'Cannon', emoji: 'üí£', cost: 3, hp: 280, damage: 35, range: 5.5, attackSpeed: 1100, lifetime: 30, targets: 'ground' },
                tombstone: { cardType: 'building', name: 'Tombstone', emoji: 'ü™¶', cost: 3, hp: 220, lifetime: 40, spawnSpeed: 2900, spawnId: 'skeletons', spawnOnDeath: 4 },
                infernoTower: { cardType: 'building', name: 'Inferno Tower', emoji: 'üî•üóº', cost: 5, hp: 350, damage: 12, damageRamp: 1.25, maxDamage: 180, range: 6, attackSpeed: 400, lifetime: 40, targets: 'any' },
                goblinHut: { cardType: 'building', name: 'Goblin Hut', emoji: 'üõñ', cost: 5, hp: 300, lifetime: 50, spawnSpeed: 4900, spawnId: 'spearGoblins' },
                bombTower: { cardType: 'building', name: 'Bomb Tower', emoji: 'üí£üóº', cost: 4, hp: 380, damage: 45, range: 5, attackSpeed: 1600, lifetime: 35, targets: 'ground', splashDamage: true, splashRadius: 15 }
            };

            let playerDeck = [];
            let playerDeckFull = [];
            let playerHand = [];
            let drawPile = [];

            // --- Game Setup ---
            function initGame() {
                // This function now resets the game and opens the deck builder
                clearInterval(gameLoopInterval);
                clearInterval(timerInterval);
                clearInterval(elixirInterval);
                clearInterval(aiInterval);

                // Reset states
                elixir = 5;
                aiElixir = 5;
                gameTime = 180;
                gameObjects = [];
                nextId = 0;
                selectedTroop = null;
                gameBoard.innerHTML = `
                    <div class="river absolute w-full h-1/12 top-1/2 -translate-y-1/2"></div>
                    <div class="bridge absolute w-1/5 h-1/12 left-1/6 top-1/2 -translate-y-1/2 rounded"></div>
                    <div class="bridge absolute w-1/5 h-1/12 right-1/6 top-1/2 -translate-y-1/2 rounded"></div>
                `;
                 messageModal.classList.add('hidden');
                
                openDeckBuilder();
            }

            function startGame() {
                deckBuilderModal.classList.add('hidden');

                // Create towers
                // Player towers
                createTower('player', 'king', 50, 88, 2000);
                createTower('player', 'princess', 20, 75, 1000);
                createTower('player', 'princess', 80, 75, 1000);
                
                // AI towers
                createTower('ai', 'king', 50, 12, 2000);
                createTower('ai', 'princess', 20, 25, 1000);
                createTower('ai', 'princess', 80, 25, 1000);

                // Setup initial hand from the built deck
                playerDeckFull = [...playerDeck].sort(() => Math.random() - 0.5);
                playerHand = playerDeckFull.slice(0, HAND_SIZE);
                drawPile = playerDeckFull.slice(HAND_SIZE);
                
                drawCards();
                updateUI();

                // Start game loops
                clearInterval(gameLoopInterval);
                clearInterval(timerInterval);
                clearInterval(elixirInterval);
                clearInterval(aiInterval);

                gameLoopInterval = setInterval(gameLoop, 1000 / 30); // 30 FPS
                elixirInterval = setInterval(generateElixir, 2000); // Normal elixir generation
                aiInterval = setInterval(aiLogic, 3000); // AI makes a decision every 3 seconds
                timerInterval = setInterval(updateTimer, 1000);
                updateTimer(); // Initial call to set double elixir if needed
            }

            function createTower(owner, type, x, y, hp) {
                const tower = {
                    id: nextId++,
                    objType: 'tower',
                    owner,
                    type,
                    x, y,
                    hp,
                    maxHp: hp,
                    damage: type === 'king' ? 25 : 20,
                    range: 2.4, // Reduced range to ensure it doesn't cross the river
                    attackSpeed: 2000, // ms
                    lastAttack: 0,
                    el: document.createElement('div')
                };

                if (type === 'king') {
                    tower.isActivated = false;
                }

                tower.el.className = `tower ${owner} ${type}-tower w-[12%] h-[12%]`;
                tower.el.style.left = `${x}%`;
                tower.el.style.top = `${y}%`;
                tower.el.style.transform = 'translate(-50%, -50%)';
                if(owner === 'player') tower.el.style.backgroundColor = '#87CEEB';
                if(owner === 'ai') tower.el.style.backgroundColor = '#F08080';

                const healthBar = createHealthBar();
                tower.el.appendChild(healthBar.bar);
                tower.healthBarInner = healthBar.inner;
                
                gameBoard.appendChild(tower.el);
                gameObjects.push(tower);
            }

            function createHealthBar() {
                const bar = document.createElement('div');
                bar.className = 'health-bar';
                const inner = document.createElement('div');
                inner.className = 'health-bar-inner';
                bar.appendChild(inner);
                return { bar, inner };
            }

            // --- Deck Building ---
            function openDeckBuilder() {
                deckBuilderModal.classList.remove('hidden');
                playerDeck = []; // Start with an empty deck
                renderDeckBuilder();
            }

            function renderDeckBuilder() {
                // Render Deck
                currentDeckEl.innerHTML = '';
                playerDeck.forEach((cardId, index) => {
                    const troop = CARD_DATA[cardId];
                    const cardEl = createCardElement(cardId, troop);
                    cardEl.addEventListener('click', () => removeDeckCard(index));
                    currentDeckEl.appendChild(cardEl);
                });

                // Render Collection
                cardCollectionEl.innerHTML = '';
                Object.keys(CARD_DATA).forEach(cardId => {
                    const troop = CARD_DATA[cardId];
                    const cardEl = createCardElement(cardId, troop);
                    cardEl.addEventListener('click', () => selectCollectionCard(cardId));
                    if (playerDeck.includes(cardId)) {
                        cardEl.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                    cardCollectionEl.appendChild(cardEl);
                });
                
                // Update button state and count
                deckCountEl.textContent = playerDeck.length;
                if (playerDeck.length === DECK_SIZE) {
                    startBattleButton.disabled = false;
                } else {
                    startBattleButton.disabled = true;
                }
            }
            
            function createCardElement(cardId, troop) {
                const cardEl = document.createElement('div');
                cardEl.className = 'card bg-gray-700 rounded-lg p-2 text-center border-2 border-gray-500 hover:border-yellow-400 cursor-pointer';
                cardEl.dataset.troop = cardId;
                cardEl.innerHTML = `
                        <div class="font-bold text-sm">${troop.name}</div>
                        <div class="text-3xl my-1">${troop.emoji}</div>
                        <div class="font-bold text-purple-400 text-lg">${troop.cost} Elixir</div>
                    `;
                return cardEl;
            }

            function selectCollectionCard(cardId) {
                if (playerDeck.length < DECK_SIZE && !playerDeck.includes(cardId)) {
                    playerDeck.push(cardId);
                    renderDeckBuilder();
                }
            }

            function removeDeckCard(index) {
                playerDeck.splice(index, 1);
                renderDeckBuilder();
            }

            // --- Card Management ---
            function drawCards() {
                cardHandEl.innerHTML = '';
                playerHand.forEach(cardId => {
                    const troop = CARD_DATA[cardId];
                    const cardEl = createCardElement(cardId, troop);
                    cardEl.addEventListener('click', () => selectCard(cardId, cardEl));
                    cardHandEl.appendChild(cardEl);
                });
                updateCardAvailability();
            }

            function selectCard(troopId, cardEl) {
                if (CARD_DATA[troopId].cost > elixir) {
                    // Maybe add a visual indicator for "not enough elixir"
                    return;
                }
                
                // Deselect if clicking the same card
                if (selectedTroop === troopId) {
                    selectedTroop = null;
                    cardEl.classList.remove('selected');
                } else {
                    // Deselect previous
                    const prevSelected = cardHandEl.querySelector('.selected');
                    if (prevSelected) prevSelected.classList.remove('selected');
                    
                    // Select new
                    selectedTroop = troopId;
                    cardEl.classList.add('selected');
                }
            }

            function updateCardAvailability() {
                const cards = cardHandEl.querySelectorAll('.card');
                cards.forEach(card => {
                    const cost = CARD_DATA[card.dataset.troop].cost;
                    if (cost > elixir) {
                        card.classList.add('disabled');
                    } else {
                        card.classList.remove('disabled');
                    }
                });
            }


            // --- Game Logic ---
            gameBoard.addEventListener('click', (e) => {
                if (!selectedTroop) return;

                const cardData = CARD_DATA[selectedTroop];
                if (elixir < cardData.cost) return;
                
                // BUG FIX: The coordinate calculation needs to be INSIDE the event listener
                // to get the location of each individual click.
                const rect = gameBoard.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width * 100;
                const y = (e.clientY - rect.top) / rect.height * 100;

                if (cardData.cardType === 'troop' || cardData.cardType === 'building') {
                    // Player can only place troops/buildings on their side
                    if (y < 55) return;
                    elixir -= cardData.cost;
                    if (cardData.cardType === 'troop') {
                        createTroop('player', selectedTroop, x, y);
                    } else {
                        createBuilding('player', selectedTroop, x, y);
                    }
                } else if (cardData.cardType === 'spell') {
                    elixir -= cardData.cost;
                    castSpell('player', selectedTroop, x, y);
                }

                // Cycle card
                cycleCard(selectedTroop);

                // Deselect card
                selectedTroop = null;
                const selectedCardEl = cardHandEl.querySelector('.selected');
                if (selectedCardEl) selectedCardEl.classList.remove('selected');
                
                drawCards();
                updateUI();
            });

            function cycleCard(playedCardId) {
                const playedCardIndex = playerHand.indexOf(playedCardId);
                if (playedCardIndex > -1) {
                    // Move played card to back of draw pile
                    const playedCard = playerHand.splice(playedCardIndex, 1)[0];
                    drawPile.push(playedCard);
                    
                    // Draw next card from pile into hand
                    const nextCard = drawPile.shift();
                    if (nextCard) {
                        playerHand.push(nextCard);
                    }
                }
            }

            function createTroop(owner, troopId, x, y) {
                const data = CARD_DATA[troopId];

                if (data.spawnIds) { // For cards like Goblin Gang
                     data.spawnIds.forEach(spawnInfo => {
                        for (let i = 0; i < spawnInfo.count; i++) {
                            createTroop(owner, spawnInfo.id, x, y);
                        }
                     });
                     return; // Stop after spawning from the gang
                }

                if (data.spawnCount > 1) {
                    for (let i = 0; i < data.spawnCount; i++) {
                        // Spawn in a small random radius
                        const angle = Math.random() * 2 * Math.PI;
                        const radius = Math.random() * (data.spawnRadius || 10);
                        const spawnX = x + (radius / gameBoard.clientWidth * 100) * Math.cos(angle);
                        const spawnY = y + (radius / gameBoard.clientHeight * 100) * Math.sin(angle);
                        createSingleTroop(owner, troopId, spawnX, spawnY);
                    }
                } else {
                    createSingleTroop(owner, troopId, x, y);
                }
            }

            function createSingleTroop(owner, troopId, x, y) {
                const data = CARD_DATA[troopId];
                const troop = {
                    id: nextId++,
                    objType: 'troop',
                    owner,
                    troopId,
                    x, y,
                    hp: data.hp,
                    maxHp: data.hp,
                    ...data,
                    target: null,
                    lastAttack: 0,
                    isCharging: false, // For Prince
                    chargeDistance: 0, // For Prince
                    frozenUntil: 0,
                    stunnedUntil: 0,
                    rageUntil: 0,
                    originalSpeed: data.speed,
                    originalAttackSpeed: data.attackSpeed,
                    el: document.createElement('div')
                };
                troop.el.className = `troop w-10 h-10`;
                troop.el.style.left = `${x}%`;
                troop.el.style.top = `${y}%`;
                troop.el.style.transform = 'translate(-50%, -50%)';
                troop.el.innerHTML = data.emoji;
                if (owner === 'player') {
                    troop.el.style.backgroundColor = 'rgba(135, 206, 250, 0.7)'; // Light Sky Blue
                     troop.el.style.border = '2px solid #4682B4'; // Steel Blue
                } else {
                     troop.el.style.backgroundColor = 'rgba(240, 128, 128, 0.7)'; // Light Coral
                    troop.el.style.border = '2px solid #CD5C5C'; // Indian Red
                }

                const healthBar = createHealthBar();
                troop.el.appendChild(healthBar.bar);
                troop.healthBarInner = healthBar.inner;

                gameBoard.appendChild(troop.el);
                gameObjects.push(troop);
            }
            
            function createBuilding(owner, buildingId, x, y) {
                const data = CARD_DATA[buildingId];
                const building = {
                    id: nextId++,
                    objType: 'building',
                    owner,
                    buildingId,
                    x, y,
                    hp: data.hp,
                    maxHp: data.hp,
                    ...data,
                    target: null,
                    lastAttack: 0,
                    lastSpawn: Date.now(),
                    currentDamage: data.damage, // For Inferno Tower
                    currentTargetId: null, // For Inferno Tower
                    frozenUntil: 0,
                    el: document.createElement('div')
                };
                building.el.className = 'building w-[10%] h-[10%]';
                building.el.style.left = `${x}%`;
                building.el.style.top = `${y}%`;
                building.el.style.transform = 'translate(-50%, -50%)';
                building.el.innerHTML = data.emoji;
                 if(owner === 'player') building.el.style.backgroundColor = '#87CEEB';
                if(owner === 'ai') building.el.style.backgroundColor = '#F08080';

                const healthBar = createHealthBar();
                building.el.appendChild(healthBar.bar);
                building.healthBarInner = healthBar.inner;

                gameBoard.appendChild(building.el);
                gameObjects.push(building);
            }

            function castSpell(owner, spellId, x, y) {
                const spellData = CARD_DATA[spellId];
                const opponent = owner === 'player' ? 'ai' : 'player';

                // Visual effect for the spell
                const spellEffectEl = document.createElement('div');
                spellEffectEl.className = 'absolute border-4 rounded-full';
                spellEffectEl.style.left = `${x}%`;
                spellEffectEl.style.top = `${y}%`;
                spellEffectEl.style.width = `${spellData.radius * 2}%`;
                spellEffectEl.style.height = `${spellData.radius * 2}%`; // Assuming aspect ratio is ~1, good enough
                spellEffectEl.style.transform = 'translate(-50%, -50%) scale(0.5)';
                spellEffectEl.style.opacity = '1';
                spellEffectEl.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
                spellEffectEl.style.pointerEvents = 'none';

                if (spellId === 'fireball') spellEffectEl.style.borderColor = 'rgba(255, 100, 0, 0.8)';
                else if (spellId === 'arrows') spellEffectEl.style.borderColor = 'rgba(150, 150, 150, 0.8)';
                else if (spellId === 'zap') spellEffectEl.style.borderColor = 'rgba(100, 100, 255, 0.8)';
                else if (spellId === 'freeze') spellEffectEl.style.borderColor = 'rgba(173, 216, 230, 0.8)';
                else if (spellId === 'rage') spellEffectEl.style.borderColor = 'rgba(255, 0, 255, 0.8)';


                gameBoard.appendChild(spellEffectEl);

                requestAnimationFrame(() => {
                    spellEffectEl.style.transform = 'translate(-50%, -50%) scale(1)';
                    spellEffectEl.style.opacity = '0';
                });

                setTimeout(() => spellEffectEl.remove(), 300);

                // Find and affect targets based on spell type
                if (spellId === 'theLog') {
                    const targets = gameObjects.filter(obj => obj.owner === opponent && obj.hp > 0 && obj.type === 'ground');
                    targets.forEach(target => {
                        // Check if target is within the log's path (a vertical rectangle)
                        const isinX = Math.abs(target.x - x) < spellData.width / 2;
                        const isinY = owner === 'player' ? (target.y < y) : (target.y > y);
                        if (isinX && isinY) {
                            dealSingleDamage({ damage: spellData.damage }, target);
                        }
                    });
                    return;
                }

                if (spellId === 'rage' || spellId === 'freeze') {
                    const targets = gameObjects.filter(obj => obj.hp > 0);
                     targets.forEach(target => {
                        const distance = getDistance({x, y}, target);
                        if (distance <= spellData.radius) {
                            if (spellId === 'rage' && target.owner === owner) {
                                target.rageUntil = Date.now() + spellData.duration;
                                target.speed = target.originalSpeed * spellData.speedBoost;
                                target.attackSpeed = target.originalAttackSpeed / spellData.attackSpeedBoost;
                            } else if (spellId === 'freeze') {
                                target.frozenUntil = Date.now() + spellData.duration;
                            }
                        }
                    });
                    return;
                }

                // Default damage spell logic
                const targets = gameObjects.filter(obj => obj.owner === opponent && obj.hp > 0);
                targets.forEach(target => {
                    const distance = getDistance({x, y}, target);
                    if (distance <= spellData.radius) {
                        dealSingleDamage({ damage: spellData.damage }, target);
                        if(spellData.stunDuration) {
                            target.stunnedUntil = Date.now() + spellData.stunDuration;
                        }
                    }
                });
            }

            function createProjectile(startObj, endObj) {
                const projectileEl = document.createElement('div');
                projectileEl.className = 'projectile';
                gameBoard.appendChild(projectileEl);

                const startRect = startObj.el.getBoundingClientRect();
                const endRect = endObj.el.getBoundingClientRect();
                const boardRect = gameBoard.getBoundingClientRect();

                const startX = startRect.left + startRect.width / 2 - boardRect.left;
                const startY = startRect.top + startRect.height / 2 - boardRect.top;
                const endX = endRect.left + endRect.width / 2 - boardRect.left;
                const endY = endRect.top + endRect.height / 2 - boardRect.top;

                projectileEl.style.left = `${startX}px`;
                projectileEl.style.top = `${startY}px`;

                const duration = 0.3; // seconds
                projectileEl.style.transition = `transform ${duration}s linear`;
                
                requestAnimationFrame(() => {
                    projectileEl.style.transform = `translate(${endX - startX}px, ${endY - startY}px)`;
                });

                setTimeout(() => {
                    projectileEl.remove();
                    
                    if(startObj.splashDamage) {
                        dealSplashDamage(startObj, endObj);
                    } else {
                        dealSingleDamage(startObj, endObj);
                    }
                }, duration * 1000);
            }

            function gameLoop() {
                if(gameTime <= 0) return;
                const objectsToRemove = [];

                // Update and draw all game objects
                gameObjects.forEach(obj => {
                    // Check for status effects
                    if (Date.now() < obj.frozenUntil || Date.now() < obj.stunnedUntil) {
                        // This object is stunned/frozen, skip its logic
                        if (obj.el.style.filter !== 'brightness(0.5)') obj.el.style.filter = 'brightness(0.5)';
                        return;
                    } else {
                         if (obj.el.style.filter === 'brightness(0.5)') obj.el.style.filter = '';
                    }

                    // Handle Rage timeout
                    if (obj.rageUntil > 0 && Date.now() > obj.rageUntil) {
                        obj.rageUntil = 0;
                        obj.speed = obj.originalSpeed;
                        obj.attackSpeed = obj.originalAttackSpeed;
                    }


                    // Building lifetime decay
                    if (obj.objType === 'building' && obj.lifetime) {
                        const hpLossPerFrame = obj.maxHp / (obj.lifetime * 30); // 30fps
                        obj.hp -= hpLossPerFrame;
                    }

                    if (obj.hp <= 0) {
                        // Tombstone death spawn
                        if (obj.objType === 'building' && obj.spawnOnDeath) {
                             for (let i = 0; i < obj.spawnOnDeath; i++) {
                                createTroop(obj.owner, obj.spawnId, obj.x, obj.y);
                             }
                        }
                        objectsToRemove.push(obj);
                        return;
                    }

                    if (obj.objType === 'troop') {
                        // Witch Spawning
                        if (obj.spawnId && (!obj.lastSpawn || Date.now() - obj.lastSpawn > obj.spawnSpeed)) {
                            obj.lastSpawn = Date.now();
                            createTroop(obj.owner, obj.spawnId, obj.x, obj.y);
                        }

                        findTarget(obj);
                        
                        if (obj.target) {
                            const dist = getDistance(obj, obj.target);
                            if (dist <= obj.range * 10) { // range is an abstract unit, multiply for pixel distance approx.
                                attack(obj, obj.target);
                                obj.chargeDistance = 0; // Reset charge distance on attack
                                if (obj.isCharging) {
                                    obj.isCharging = false;
                                    obj.el.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
                                }
                            } else {
                                move(obj, obj.target);
                            }
                        } else {
                            // No enemies, move towards opponent's side
                            let targetY = obj.owner === 'player' ? -10 : 110;
                            move(obj, {x: obj.x, y: targetY});
                        }
                    } else if (obj.objType === 'tower') {
                        let canAttack = true;

                        // King tower activation logic
                        if (obj.type === 'king' && !obj.isActivated) {
                            canAttack = false;
                            
                            const activationRange = 3 * 10;
                            const isEnemyNearby = gameObjects.some(
                                enemy => enemy.owner !== obj.owner && 
                                         enemy.objType === 'troop' && 
                                         getDistance(obj, enemy) <= activationRange
                            );

                            if (isEnemyNearby) {
                                obj.isActivated = true;
                                canAttack = true;
                            }
                        }

                        // Standard attack logic for active towers.
                        if (canAttack) {
                            findTarget(obj);
                            if (obj.target) {
                                attack(obj, obj.target);
                            }
                        }
                    } else if (obj.objType === 'building') {
                        // Building-specific logic
                        if (obj.damage > 0) { // It's a defensive building like Cannon
                             findTarget(obj);
                            if (obj.target) {
                                attack(obj, obj.target);
                            }
                        }
                        if (obj.spawnId) { // It's a spawner like Tombstone
                            const now = Date.now();
                            if (now - obj.lastSpawn > obj.spawnSpeed) {
                                obj.lastSpawn = now;
                                createTroop(obj.owner, obj.spawnId, obj.x, obj.y);
                            }
                        }
                    }

                    // Update visual position
                    obj.el.style.left = `${obj.x}%`;
                    obj.el.style.top = `${obj.y}%`;
                    
                    // Update health bar
                    const healthPercentage = (obj.hp / obj.maxHp) * 100;
                    obj.healthBarInner.style.width = `${healthPercentage}%`;
                });
                
                // Cleanup dead objects
                objectsToRemove.forEach(obj => {
                    obj.el.remove();
                    gameObjects = gameObjects.filter(g => g.id !== obj.id);
                });

                checkGameOver();
                updateTowerCounts();
            }

            function dealSplashDamage(attacker, primaryTarget) {
                 if (!primaryTarget) return;

                 // Damage all enemy units around the primary target
                const enemies = gameObjects.filter(o => o.owner !== attacker.owner && o.hp > 0);
                enemies.forEach(enemy => {
                    if (getDistance(primaryTarget, enemy) < attacker.splashRadius) {
                        dealSingleDamage(attacker, enemy);
                    }
                });
            }
            
            function dealSingleDamage(attacker, target) {
                if (!target) return;
                target.hp -= attacker.damage;
                if(attacker.stunDuration) {
                    target.stunnedUntil = Date.now() + attacker.stunDuration;
                }
                // Flash effect on hit
                target.el.style.filter = 'brightness(2)';
                setTimeout(() => target.el.style.filter = '', 100);
            }

            function findTarget(attacker) {
                let potentialTargets = gameObjects.filter(obj => 
                    obj.owner !== attacker.owner && obj.hp > 0 && 
                    (obj.objType === 'troop' || obj.objType === 'tower' || obj.objType === 'building')
                );
                
                // Towers and Cannons targeting logic
                if (attacker.objType === 'tower' || (attacker.objType === 'building' && attacker.damage > 0)) {
                    // Inferno tower can hit air and ground
                    if (attacker.targets !== 'any') {
                        potentialTargets = potentialTargets.filter(obj => obj.objType === 'troop');
                        if (attacker.targets === 'ground') {
                            potentialTargets = potentialTargets.filter(obj => obj.type !== 'air');
                        }
                    } else {
                        potentialTargets = potentialTargets.filter(obj => obj.objType === 'troop' || obj.objType === 'building' || obj.objType === 'tower');
                    }
                }

                // Giant/Hog/Golem etc. logic
                if (attacker.targets === 'buildings') {
                    const opponentBuildings = potentialTargets.filter(t => t.objType === 'tower' || t.objType === 'building');
                    if (opponentBuildings.length > 0) {
                        potentialTargets = opponentBuildings;
                    }
                }

                let closestTarget = null;
                let minDistance = Infinity;

                potentialTargets.forEach(target => {
                    const dist = getDistance(attacker, target);
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestTarget = target;
                    }
                });
                
                attacker.target = closestTarget;
            }
            
            function move(obj, target) {
                 const angle = Math.atan2(target.y - obj.y, target.x - obj.x);
                 const distance = obj.speed * 0.2;
                 obj.x += Math.cos(angle) * distance; 
                 obj.y += Math.sin(angle) * distance;

                 // Prince charge mechanic
                 if (obj.canCharge) {
                    obj.chargeDistance += distance;
                    if (obj.chargeDistance > 30 && !obj.isCharging) { // 30 is the charge threshold
                        obj.isCharging = true;
                        obj.el.style.boxShadow = '0 0 20px rgba(255, 100, 255, 0.9)'; // Visual indicator for charge
                    }
                 }
            }

            function attack(attacker, target) {
                const now = Date.now();
                const attackSpeed = attacker.attackSpeed || 1500;
                if (now - attacker.lastAttack > attackSpeed) {
                    attacker.lastAttack = now;
                    
                    let finalAttacker = {...attacker};

                    // Prince charge damage
                    if (attacker.isCharging) {
                        finalAttacker.damage *= 2;
                    }

                    // Inferno Tower damage ramp
                    if (attacker.damageRamp) {
                        if (attacker.currentTargetId === target.id) {
                            attacker.currentDamage = Math.min(attacker.maxDamage, attacker.currentDamage * attacker.damageRamp);
                        } else {
                            attacker.currentDamage = attacker.damage; // Reset damage
                        }
                        finalAttacker.damage = attacker.currentDamage;
                        attacker.currentTargetId = target.id;
                    }


                    if (attacker.attackType === 'melee-splash') {
                        // Damage all enemies in a circle around the attacker
                        const enemies = gameObjects.filter(o => o.owner !== attacker.owner && o.hp > 0);
                        enemies.forEach(enemy => {
                            if (getDistance(finalAttacker, enemy) <= finalAttacker.range * 10) {
                                dealSingleDamage(finalAttacker, enemy);
                            }
                        });
                        // Visual effect for splash
                        const splashEl = document.createElement('div');
                        splashEl.className = 'absolute border-2 border-white rounded-full';
                        splashEl.style.width = `${attacker.range * 20}px`;
                        splashEl.style.height = `${attacker.range * 20}px`;
                        splashEl.style.left = `${attacker.x}%`;
                        splashEl.style.top = `${attacker.y}%`;
                        splashEl.style.transform = 'translate(-50%, -50%)';
                        splashEl.style.pointerEvents = 'none';
                        splashEl.style.opacity = '0.5';
                        gameBoard.appendChild(splashEl);
                        setTimeout(() => splashEl.remove(), 200);


                    } else if (attacker.range > 2) { // Ranged attack
                        createProjectile(finalAttacker, target);
                    } else { // Melee attack
                        dealSingleDamage(finalAttacker, target);
                    }
                }
            }

            function getDistance(obj1, obj2) {
                if (!obj1 || !obj2) return Infinity;
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            function generateElixir() {
                 if (gameTime <= 0) return;

                 if (elixir < maxElixir) {
                    elixir++;
                 }
                 if (aiElixir < maxElixir) {
                    aiElixir++;
                 }
                 updateUI();
            }
            
            function updateTimer() {
                if (gameTime > 0) {
                    gameTime--;
                    timerEl.textContent = gameTime;
                    // Check for Double Elixir
                    if (gameTime === 60) {
                        clearInterval(elixirInterval);
                        elixirInterval = setInterval(generateElixir, 1000); // Faster elixir
                        // Visual indicator for double elixir
                        timerEl.classList.add('text-purple-400', 'font-extrabold', 'animate-pulse');
                    }
                } else {
                    clearInterval(timerInterval);
                    endGame();
                }
            }
            
            function aiLogic() {
                if(gameTime <= 0) return;
                const placeableCards = Object.keys(CARD_DATA);
                
                const randomCardId = placeableCards[Math.floor(Math.random() * placeableCards.length)];
                const cardData = CARD_DATA[randomCardId];

                // AI now checks if it has enough elixir
                if (aiElixir >= cardData.cost) {
                    const deployChance = aiElixir > 7 ? 0.8 : 0.5;
                    if (Math.random() < deployChance) { 
                        aiElixir -= cardData.cost;
                        
                        if (cardData.cardType === 'troop' || cardData.cardType === 'building') {
                            const x = Math.random() * 80 + 10; // 10% to 90% of width
                            const y = Math.random() * 40 + 5; // 5% to 45% of height (AI side)
                            if (cardData.cardType === 'troop') {
                                createTroop('ai', randomCardId, x, y);
                            } else {
                                createBuilding('ai', randomCardId, x, y);
                            }
                        } else if (cardData.cardType === 'spell') {
                            // AI tries to target a player troop on its side
                            const playerTroops = gameObjects.filter(o => o.owner === 'player' && o.y < 50);
                            if (playerTroops.length > 0) {
                                const targetTroop = playerTroops[Math.floor(Math.random() * playerTroops.length)];
                                castSpell('ai', randomCardId, targetTroop.x, targetTroop.y);
                            } else {
                                // Or targets a random tower if no troops are available
                                const playerTowers = gameObjects.filter(o => o.owner === 'player' && o.objType === 'tower');
                                if (playerTowers.length > 0) {
                                    const targetTower = playerTowers[Math.floor(Math.random() * playerTowers.length)];
                                    castSpell('ai', randomCardId, targetTower.x, targetTower.y);
                                }
                            }
                        }
                    }
                }
            }

            function updateTowerCounts() {
                const playerTowerCount = gameObjects.filter(o => o.objType === 'tower' && o.owner === 'player').length;
                const aiTowerCount = gameObjects.filter(o => o.objType === 'tower' && o.owner === 'ai').length;
                playerTowersEl.textContent = playerTowerCount;
                aiTowersEl.textContent = aiTowerCount;
            }

            // --- Game Over ---
            function checkGameOver() {
                const playerKing = gameObjects.find(o => o.owner === 'player' && o.type === 'king');
                const aiKing = gameObjects.find(o => o.owner === 'ai' && o.type === 'king');

                if (!playerKing) {
                    endGame('AI Wins!');
                } else if (!aiKing) {
                    endGame('You Win!');
                }
            }
            
            function endGame(result) {
                clearInterval(gameLoopInterval);
                clearInterval(timerInterval);
                
                let title = '';
                let text = '';
                
                if (result) {
                     title = result;
                     text = "The King Tower has been destroyed!";
                } else { // Timeout
                    const playerTowerCount = gameObjects.filter(o => o.objType === 'tower' && o.owner === 'player').length;
                    const aiTowerCount = gameObjects.filter(o => o.objType === 'tower' && o.owner === 'ai').length;

                    if(playerTowerCount > aiTowerCount) {
                        title = 'You Win on Points!';
                        text = `You had ${playerTowerCount} towers remaining to the AI's ${aiTowerCount}.`;
                    } else if (aiTowerCount > playerTowerCount) {
                         title = 'AI Wins on Points!';
                         text = `The AI had ${aiTowerCount} towers remaining to your ${playerTowerCount}.`;
                    } else {
                        title = 'It\'s a Draw!';
                        text = 'Both sides had the same number of towers remaining.';
                    }
                }
                
                messageTitle.textContent = title;
                messageText.textContent = text;
                messageModal.classList.remove('hidden');
            }
            
            restartButton.addEventListener('click', initGame);
            startBattleButton.addEventListener('click', startGame);

            // --- UI Updates ---
            function updateUI() {
                elixirCountEl.textContent = elixir;
                elixirBarFill.style.width = `${(elixir / maxElixir) * 100}%`;
                updateCardAvailability();
            }

            // Initial game start
            openDeckBuilder();
        });

    </script>
</body>
</html>











