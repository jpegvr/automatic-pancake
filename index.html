<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale Clone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents scrolling on mobile */
        }
        .font-bangers {
            font-family: 'Bangers', cursive;
        }
        #game-board {
            background-color: #4CAF50; /* Grassy field */
            background-image:
                linear-gradient(to right, rgba(0,0,0,0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0,0,0,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            position: relative;
            overflow: hidden;
            border: 4px solid #8B4513; /* Wooden border */
        }
        .bridge {
            background-color: #DAA520; /* Wooden plank color */
            border: 2px solid #8B4513;
            z-index: 1;
        }
        .river {
            background: linear-gradient(to right, #4682B4, #87CEEB); /* Steel Blue to Sky Blue */
            z-index: 0;
        }
        .tower {
            background-color: #A9A9A9; /* Stone color */
            border: 3px solid #696969;
            border-radius: 50% 50% 10% 10% / 20% 20% 10% 10%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            position: absolute;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .king-tower::before {
            content: 'üëë';
            font-size: 1.5rem; /* 24px */
        }
        .princess-tower::before {
             content: 'üèπ';
             font-size: 1.25rem; /* 20px */
        }
        .building {
            background-color: #DEB887; /* BurlyWood */
            border: 3px solid #8B4513;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            position: absolute;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-size: 2rem;
        }

        .troop {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem; /* 20px */
            transition: transform 0.1s linear, top 0.1s linear, left 0.1s linear;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .health-bar {
            position: absolute;
            bottom: -8px;
            width: 80%;
            height: 5px;
            background-color: #E0E0E0;
            border-radius: 2.5px;
            overflow: hidden;
        }
        .health-bar-inner {
            height: 100%;
            background-color: #4CAF50; /* Green health */
            border-radius: 2.5px;
            transition: width 0.2s;
        }
        .projectile {
            position: absolute;
            background-color: #FFD700;
            border-radius: 50%;
            width: 10px;
            height: 10px;
            z-index: 50;
            box-shadow: 0 0 5px #FFD700;
        }
        #elixir-bar-fill {
            transition: width 0.5s linear;
        }
        .card {
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }
        .card.selected {
            transform: translateY(-15px) scale(1.1);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.9);
        }
        .card.disabled {
            filter: grayscale(100%);
            cursor: not-allowed;
        }

        /* Message Modal */
        #message-modal {
            transition: opacity 0.3s ease-in-out;
        }
        #message-box {
            animation: slide-in 0.5s forwards;
        }
        @keyframes slide-in {
            0% { transform: translateY(-100px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body class="bg-gray-800 flex flex-col items-center justify-center min-h-screen p-4 text-white">

    <h1 class="text-4xl md:text-6xl font-bangers text-yellow-400 mb-4 tracking-wider">TOWER DUEL</h1>

    <div class="w-full max-w-sm md:max-w-md lg:max-w-lg aspect-[9/16] relative">
        <div id="game-board" class="w-full h-full rounded-lg shadow-2xl">
            <div class="river absolute w-full h-1/12 top-1/2 -translate-y-1/2"></div>
            <div class="bridge absolute w-1/5 h-1/12 left-1/6 top-1/2 -translate-y-1/2 rounded"></div>
            <div class="bridge absolute w-1/5 h-1/12 right-1/6 top-1/2 -translate-y-1/2 rounded"></div>
        </div>

        <div class="absolute top-2 left-2 text-lg font-bold bg-black bg-opacity-50 px-2 py-1 rounded">
            AI: <span id="ai-towers">3</span>
        </div>
         <div class="absolute top-2 right-2 text-lg font-bold bg-black bg-opacity-50 px-2 py-1 rounded">
            Time: <span id="timer">180</span>s
        </div>
         <div class="absolute bottom-2 left-2 text-lg font-bold bg-black bg-opacity-50 px-2 py-1 rounded">
            You: <span id="player-towers">3</span>
        </div>
    </div>


    <div class="w-full max-w-sm md:max-w-md lg:max-w-lg mt-4">
        <div class="w-full bg-gray-600 rounded-full h-6 border-2 border-purple-400 mb-2">
            <div id="elixir-bar-fill" class="bg-purple-600 h-full rounded-full" style="width: 30%;"></div>
            <div class="relative -top-6 w-full h-full flex items-center justify-center">
                <span id="elixir-count" class="font-bold text-lg">3</span> / 10
            </div>
        </div>

        <div id="card-hand" class="grid grid-cols-4 gap-2">
            </div>
    </div>
    
    <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div id="message-box" class="bg-gray-700 p-8 rounded-lg shadow-2xl text-center border-4 border-yellow-400">
            <h2 id="message-title" class="text-4xl font-bangers text-yellow-400 mb-4"></h2>
            <p id="message-text" class="mb-6 text-lg"></p>
            <button id="restart-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-xl font-bangers tracking-wider">Play Again</button>
        </div>
    </div>

    <div id="deck-builder-modal" class="fixed inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-50 p-4">
        <div class="bg-gray-700 p-6 rounded-lg shadow-2xl w-full max-w-2xl border-4 border-yellow-400">
            <h2 class="text-3xl font-bangers text-yellow-400 mb-4 text-center">Build Your Deck</h2>
            
            <h3 class="font-bold text-lg mb-2 text-purple-300">Your Deck (<span id="deck-count">0</span>/8)</h3>
            <div id="current-deck" class="grid grid-cols-4 sm:grid-cols-8 gap-2 bg-gray-800 p-2 rounded-md min-h-[120px] mb-4 border-2 border-gray-600">
                </div>

            <h3 class="font-bold text-lg mb-2 text-green-300">Card Collection</h3>
            <div id="card-collection" class="grid grid-cols-4 sm:grid-cols-6 gap-2 bg-gray-800 p-2 rounded-md max-h-[300px] overflow-y-auto">
                </div>

            <button id="start-battle-button" class="mt-6 w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-xl font-bangers tracking-wider disabled:bg-gray-500 disabled:cursor-not-allowed">Start Battle</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameBoard = document.getElementById('game-board');
            const elixirBarFill = document.getElementById('elixir-bar-fill');
            const elixirCountEl = document.getElementById('elixir-count');
            const cardHandEl = document.getElementById('card-hand');
            const timerEl = document.getElementById('timer');
            const playerTowersEl = document.getElementById('player-towers');
            const aiTowersEl = document.getElementById('ai-towers');
            
            const messageModal = document.getElementById('message-modal');
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const restartButton = document.getElementById('restart-button');
            
            const deckBuilderModal = document.getElementById('deck-builder-modal');
            const currentDeckEl = document.getElementById('current-deck');
            const cardCollectionEl = document.getElementById('card-collection');
            const startBattleButton = document.getElementById('start-battle-button');
            const deckCountEl = document.getElementById('deck-count');

            let elixir = 5;
            let aiElixir = 5;
            let maxElixir = 10;
            let selectedTroop = null;
            let gameLoopInterval = null;
            let timerInterval = null;
            let elixirInterval = null;
            let aiInterval = null;
            let gameTime = 180;
            let gameObjects = [];
            let nextId = 0;
            const DECK_SIZE = 8;
            const HAND_SIZE = 4;

            const CARD_DATA = {
                // Troops
                skeletons: { cardType: 'troop', name: 'Skeletons', emoji: 'üíÄ', cost: 1, hp: 16, damage: 6, range: 1.5, speed: 1.9, type: 'ground', spawnCount: 4, spawnRadius: 10, attackSpeed: 1000 },
                goblins: { cardType: 'troop', name: 'Goblins', emoji: 'üë∫', cost: 2, hp: 38, damage: 13, range: 1.5, speed: 2.0, type: 'ground', spawnCount: 3, spawnRadius: 10, attackSpeed: 1100 },
                spearGoblins: { cardType: 'troop', name: 'Spear Goblins', emoji: 'üî±', cost: 2, hp: 28, damage: 9, range: 5, speed: 2.0, type: 'ground', spawnCount: 3, spawnRadius: 10, attackSpeed: 1200 },
                bomber: { cardType: 'troop', name: 'Bomber', emoji: 'üí£', cost: 2, hp: 45, damage: 30, range: 4.5, speed: 1.2, type: 'ground', attackSpeed: 1800, splashDamage: true, splashRadius: 12 },
                iceGolem: { cardType: 'troop', name: 'Ice Golem', emoji: 'üßä', cost: 2, hp: 280, damage: 10, range: 1.5, speed: 0.9, type: 'ground', targets: 'buildings', attackSpeed: 2500 },
                knight: { cardType: 'troop', name: 'Knight', emoji: '‚öîÔ∏è', cost: 3, hp: 155, damage: 20, range: 1.5, speed: 1.2, type: 'ground', attackSpeed: 1200 },
                archer: { cardType: 'troop', name: 'Archer', emoji: 'üèπ', cost: 3, hp: 65, damage: 13, range: 5, speed: 1.2, type: 'ground', attackSpeed: 1000 },
                minions: { cardType: 'troop', name: 'Minions', emoji: 'ü¶á', cost: 3, hp: 48, damage: 16, range: 2.5, speed: 1.8, type: 'air', spawnCount: 3, spawnRadius: 15, attackSpeed: 1000 },
                megaMinion: { cardType: 'troop', name: 'Mega Minion', emoji: 'üëø', cost: 3, hp: 130, damage: 35, range: 2.5, speed: 1.4, type: 'air', attackSpeed: 1500 },
                dartGoblin: { cardType: 'troop', name: 'Dart Goblin', emoji: 'üéØ', cost: 3, hp: 55, damage: 11, range: 6.5, speed: 2.0, type: 'ground', attackSpeed: 700 },
                goblinGang: { cardType: 'troop', name: 'Goblin Gang', emoji: ' Gang ', cost: 3, spawnIds: [{id: 'goblins', count: 2}, {id: 'spearGoblins', count: 2}], type: 'ground' },
                guards: { cardType: 'troop', name: 'Guards', emoji: 'üõ°Ô∏è', cost: 3, hp: 20, shieldHp: 45, damage: 12, range: 1.6, speed: 1.3, type: 'ground', spawnCount: 3, spawnRadius: 10, attackSpeed: 1200 },
                miner: { cardType: 'troop', name: 'Miner', emoji: '‚õèÔ∏è', cost: 3, hp: 180, damage: 28, range: 1.5, speed: 1.4, type: 'ground', attackSpeed: 1300, canPlaceAnywhere: true },
                hogRider: { cardType: 'troop', name: 'Hog Rider', emoji: 'üêó', cost: 4, hp: 220, damage: 45, range: 1.5, speed: 2.2, type: 'ground', targets: 'buildings', attackSpeed: 1600 },
                valkyrie: { cardType: 'troop', name: 'Valkyrie', emoji: 'üë©‚Äçü¶∞', cost: 4, hp: 190, damage: 32, range: 1.5, speed: 1.3, type: 'ground', attackSpeed: 1500, attackType: 'melee-splash' },
                musketeer: { cardType: 'troop', name: 'Musketeer', emoji: 'üíÇ‚Äç‚ôÄÔ∏è', cost: 4, hp: 120, damage: 40, range: 6, speed: 1.1, type: 'ground', attackSpeed: 1200 },
                dragon: { cardType: 'troop', name: 'Dragon', emoji: 'üêâ', cost: 4, hp: 160, damage: 28, range: 4, speed: 1.4, type: 'air', attackSpeed: 1600, splashDamage: true, splashRadius: 10 },
                miniPekka: { cardType: 'troop', name: 'Mini P.E.K.K.A', emoji: '‚öôÔ∏è', cost: 4, hp: 300, damage: 90, range: 1.5, speed: 1.5, type: 'ground', attackSpeed: 1700 },
                electroWizard: { cardType: 'troop', name: 'E. Wizard', emoji: '‚ö°Ô∏èüßô', cost: 4, hp: 110, damage: 18, range: 5, speed: 1.2, type: 'ground', attackSpeed: 1800, stunDuration: 500 },
                babyDragon: { cardType: 'troop', name: 'Baby Dragon', emoji: 'ü¶ñ', cost: 4, hp: 160, damage: 25, range: 3.5, speed: 1.5, type: 'air', attackSpeed: 1500, splashDamage: true, splashRadius: 10 },
                lumberjack: { cardType: 'troop', name: 'Lumberjack', emoji: 'ü™ì', cost: 4, hp: 120, damage: 45, range: 1.5, speed: 2.4, type: 'ground', attackSpeed: 800, dropsRageOnDeath: true },
                giant: { cardType: 'troop', name: 'Giant', emoji: 'üóø', cost: 5, hp: 500, damage: 28, range: 1.5, speed: 0.8, type: 'ground', targets: 'buildings', attackSpeed: 1700 },
                wizard: { cardType: 'troop', name: 'Wizard', emoji: 'üßô', cost: 5, hp: 110, damage: 45, range: 5.5, speed: 1.1, type: 'ground', attackSpeed: 1600, splashDamage: true, splashRadius: 15 },
                witch: { cardType: 'troop', name: 'Witch', emoji: 'üßπ', cost: 5, hp: 130, damage: 18, range: 5, speed: 1.1, type: 'ground', attackSpeed: 1100, splashDamage: true, splashRadius: 8, spawnId: 'skeletons', spawnSpeed: 7000 },
                prince: { cardType: 'troop', name: 'Prince', emoji: 'üê¥', cost: 5, hp: 320, damage: 65, range: 1.6, speed: 1.7, type: 'ground', attackSpeed: 1500, canCharge: true },
                barbarians: { cardType: 'troop', name: 'Barbarians', emoji: 'üßî‚Äç‚ôÇÔ∏è', cost: 5, hp: 130, damage: 22, range: 1.5, speed: 1.1, type: 'ground', spawnCount: 4, spawnRadius: 12, attackSpeed: 1400 },
                executioner: { cardType: 'troop', name: 'Executioner', emoji: 'ü§†', cost: 5, hp: 210, damage: 30, range: 5, speed: 1.0, type: 'ground', attackSpeed: 2400, attackType: 'boomerang' },
                bowler: { cardType: 'troop', name: 'Bowler', emoji: 'üé≥', cost: 5, hp: 320, damage: 55, range: 5, speed: 0.8, type: 'ground', attackSpeed: 2500, splashDamage: true, splashRadius: 8, pushback: 1.5 },
                royalGiant: { cardType: 'troop', name: 'Royal Giant', emoji: 'üëë', cost: 6, hp: 550, damage: 35, range: 6.0, speed: 0.7, type: 'ground', targets: 'buildings', attackSpeed: 1800 },
                eliteBarbarians: { cardType: 'troop', name: 'Elite Barbarians', emoji: 'üí™', cost: 6, hp: 220, damage: 42, range: 1.5, speed: 2.1, type: 'ground', spawnCount: 2, spawnRadius: 5, attackSpeed: 1500 },
                pekka: { cardType: 'troop', name: 'P.E.K.K.A', emoji: 'ü§ñ', cost: 7, hp: 650, damage: 120, range: 1.6, speed: 0.7, type: 'ground', attackSpeed: 1900 },
                golem: { cardType: 'troop', name: 'Golem', emoji: 'ü™®', cost: 8, hp: 850, damage: 40, range: 1.5, speed: 0.6, type: 'ground', targets: 'buildings', attackSpeed: 2500 },

                // Spells
                zap: { cardType: 'spell', name: 'Zap', emoji: '‚ö°Ô∏è', cost: 2, damage: 25, radius: 12, stunDuration: 500 },
                theLog: { cardType: 'spell', name: 'The Log', emoji: 'üå≤', cost: 2, damage: 30, width: 20, type: 'groundOnly' },
                rage: { cardType: 'spell', name: 'Rage', emoji: 'üò°', cost: 2, radius: 20, duration: 6000, speedBoost: 1.35, attackSpeedBoost: 1.35 },
                arrows: { cardType: 'spell', name: 'Arrows', emoji: 'üéØ', cost: 3, damage: 35, radius: 25 },
                fireball: { cardType: 'spell', name: 'Fireball', emoji: 'üî•', cost: 4, damage: 70, radius: 15 },
                freeze: { cardType: 'spell', name: 'Freeze', emoji: 'ü•∂', cost: 4, radius: 20, duration: 3500 },
                rocket: { cardType: 'spell', name: 'Rocket', emoji: 'üöÄ', cost: 6, damage: 450, radius: 10 },
                lightning: { cardType: 'spell', name: 'Lightning', emoji: 'üå©Ô∏è', cost: 6, damage: 160, radius: 20, strikeCount: 3 },
                
                // Buildings
                cannon: { cardType: 'building', name: 'Cannon', emoji: 'üí£', cost: 3, hp: 280, damage: 35, range: 5.5, attackSpeed: 1100, lifetime: 30, targets: 'ground' },
                tombstone: { cardType: 'building', name: 'Tombstone', emoji: 'ü™¶', cost: 3, hp: 220, lifetime: 40, spawnSpeed: 2900, spawnId: 'skeletons', spawnOnDeath: 4 },
                bombTower: { cardType: 'building', name: 'Bomb Tower', emoji: 'üí£üóº', cost: 4, hp: 380, damage: 45, range: 5, attackSpeed: 1600, lifetime: 35, targets: 'ground', splashDamage: true, splashRadius: 15 },
                mortar: { cardType: 'building', name: 'Mortar', emoji: 'üåã', cost: 4, hp: 300, damage: 50, range: 11, minRange: 4, attackSpeed: 5000, lifetime: 30, targets: 'ground', splashDamage: true, splashRadius: 20 },
                infernoTower: { cardType: 'building', name: 'Inferno Tower', emoji: 'üî•üóº', cost: 5, hp: 350, damage: 12, damageRamp: 1.25, maxDamage: 180, range: 6, attackSpeed: 400, lifetime: 40, targets: 'any' },
                goblinHut: { cardType: 'building', name: 'Goblin Hut', emoji: 'üõñ', cost: 5, hp: 300, lifetime: 50, spawnSpeed: 4900, spawnId: 'spearGoblins' },
                xBow: { cardType: 'building', name: 'X-Bow', emoji: '‚úñÔ∏è', cost: 6, hp: 420, damage: 10, range: 11.5, attackSpeed: 300, lifetime: 40, targets: 'ground' },
                elixirCollector: { cardType: 'building', name: 'Elixir Collector', emoji: 'üíß', cost: 6, hp: 250, lifetime: 70, spawnSpeed: 8500, givesElixir: true }
            };

            let playerDeck = [];
            let playerDeckFull = [];
            let playerHand = [];
            let drawPile = [];

            function initGame() {
                clearInterval(gameLoopInterval);
                clearInterval(timerInterval);
                clearInterval(elixirInterval);
                clearInterval(aiInterval);
                elixir = 5;
                aiElixir = 5;
                gameTime = 180;
                gameObjects = [];
                nextId = 0;
                selectedTroop = null;
                gameBoard.innerHTML = `
                    <div class="river absolute w-full h-1/12 top-1/2 -translate-y-1/2"></div>
                    <div class="bridge absolute w-1/5 h-1/12 left-1/6 top-1/2 -translate-y-1/2 rounded"></div>
                    <div class="bridge absolute w-1/5 h-1/12 right-1/6 top-1/2 -translate-y-1/2 rounded"></div>
                `;
                 messageModal.classList.add('hidden');
                openDeckBuilder();
            }

            function startGame() {
                deckBuilderModal.classList.add('hidden');
                createTower('player', 'king', 50, 88, 2500);
                createTower('player', 'princess', 20, 75, 1000);
                createTower('player', 'princess', 80, 75, 1000);
                createTower('ai', 'king', 50, 12, 2500);
                createTower('ai', 'princess', 20, 25, 1000);
                createTower('ai', 'princess', 80, 25, 1000);
                playerDeckFull = [...playerDeck].sort(() => Math.random() - 0.5);
                playerHand = playerDeckFull.slice(0, HAND_SIZE);
                drawPile = playerDeckFull.slice(HAND_SIZE);
                drawCards();
                updateUI();
                clearInterval(gameLoopInterval);
                clearInterval(timerInterval);
                clearInterval(elixirInterval);
                clearInterval(aiInterval);
                gameLoopInterval = setInterval(gameLoop, 1000 / 30);
                elixirInterval = setInterval(generateElixir, 2000);
                aiInterval = setInterval(aiLogic, 2500);
                timerInterval = setInterval(updateTimer, 1000);
                updateTimer();
            }

            function createTower(owner, type, x, y, hp) {
                const isKing = type === 'king';
                const tower = {
                    id: nextId++,
                    objType: 'tower', owner, type, x, y, hp, maxHp: hp,
                    damage: isKing ? 40 : 35,
                    range: 7.5,
                    attackSpeed: isKing ? 1000 : 800,
                    lastAttack: 0, frozenUntil: 0, stunnedUntil: 0, rageUntil: 0,
                    speed: 0, originalSpeed: 0,
                    originalAttackSpeed: isKing ? 1000 : 800,
                    el: document.createElement('div')
                };
                if (isKing) tower.isActivated = false;
                
                tower.el.className = `tower ${owner} ${type}-tower w-[12%] h-[12%]`;
                tower.el.style.left = `${x}%`;
                tower.el.style.top = `${y}%`;
                tower.el.style.transform = 'translate(-50%, -50%)';
                if(owner === 'player') tower.el.style.backgroundColor = '#87CEEB';
                if(owner === 'ai') tower.el.style.backgroundColor = '#F08080';

                const healthBar = createHealthBar();
                tower.el.appendChild(healthBar.bar);
                tower.healthBarInner = healthBar.inner;
                gameBoard.appendChild(tower.el);
                gameObjects.push(tower);
            }

            function createHealthBar() {
                const bar = document.createElement('div');
                bar.className = 'health-bar';
                const inner = document.createElement('div');
                inner.className = 'health-bar-inner';
                bar.appendChild(inner);
                return { bar, inner };
            }

            function openDeckBuilder() {
                deckBuilderModal.classList.remove('hidden');
                playerDeck = [];
                renderDeckBuilder();
            }

            function renderDeckBuilder() {
                currentDeckEl.innerHTML = '';
                playerDeck.forEach((cardId, index) => {
                    const cardData = CARD_DATA[cardId];
                    const cardEl = createCardElement(cardId, cardData);
                    cardEl.addEventListener('click', () => removeDeckCard(index));
                    currentDeckEl.appendChild(cardEl);
                });
                cardCollectionEl.innerHTML = '';
                Object.keys(CARD_DATA).sort((a,b) => CARD_DATA[a].cost - CARD_DATA[b].cost).forEach(cardId => {
                    const cardData = CARD_DATA[cardId];
                    const cardEl = createCardElement(cardId, cardData);
                    cardEl.addEventListener('click', () => selectCollectionCard(cardId));
                    if (playerDeck.includes(cardId)) {
                        cardEl.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                    cardCollectionEl.appendChild(cardEl);
                });
                deckCountEl.textContent = playerDeck.length;
                startBattleButton.disabled = playerDeck.length !== DECK_SIZE;
            }
            
            function createCardElement(cardId, cardData) {
                const cardEl = document.createElement('div');
                cardEl.className = 'card bg-gray-700 rounded-lg p-2 text-center border-2 border-gray-500 hover:border-yellow-400 cursor-pointer flex flex-col justify-between';
                cardEl.dataset.troop = cardId;
                cardEl.innerHTML = `
                        <div class="font-bold text-sm leading-tight">${cardData.name}</div>
                        <div class="text-3xl my-1 flex-grow flex items-center justify-center">${cardData.emoji}</div>
                        <div class="font-bold text-purple-400 text-lg">${cardData.cost} Elixir</div>
                    `;
                return cardEl;
            }

            function selectCollectionCard(cardId) {
                if (playerDeck.length < DECK_SIZE && !playerDeck.includes(cardId)) {
                    playerDeck.push(cardId);
                    renderDeckBuilder();
                }
            }

            function removeDeckCard(index) {
                playerDeck.splice(index, 1);
                renderDeckBuilder();
            }

            function drawCards() {
                cardHandEl.innerHTML = '';
                playerHand.forEach(cardId => {
                    const troop = CARD_DATA[cardId];
                    const cardEl = createCardElement(cardId, troop);
                    cardEl.addEventListener('click', () => selectCard(cardId, cardEl));
                    cardHandEl.appendChild(cardEl);
                });
                updateCardAvailability();
            }

            function selectCard(troopId, cardEl) {
                if (CARD_DATA[troopId].cost > elixir) return;
                if (selectedTroop === troopId) {
                    selectedTroop = null;
                    cardEl.classList.remove('selected');
                } else {
                    const prevSelected = cardHandEl.querySelector('.selected');
                    if (prevSelected) prevSelected.classList.remove('selected');
                    selectedTroop = troopId;
                    cardEl.classList.add('selected');
                }
            }

            function updateCardAvailability() {
                const cards = cardHandEl.querySelectorAll('.card');
                cards.forEach(card => {
                    const cost = CARD_DATA[card.dataset.troop].cost;
                    card.classList.toggle('disabled', cost > elixir);
                });
            }

            gameBoard.addEventListener('click', (e) => {
                if (!selectedTroop) return;
                const cardData = CARD_DATA[selectedTroop];
                if (elixir < cardData.cost) return;
                
                const rect = gameBoard.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width * 100;
                const y = (e.clientY - rect.top) / rect.height * 100;

                if (cardData.cardType === 'troop' || cardData.cardType === 'building') {
                    if (y < 55 && !cardData.canPlaceAnywhere) return;
                    elixir -= cardData.cost;
                    if (cardData.cardType === 'troop') createTroop('player', selectedTroop, x, y);
                    else createBuilding('player', selectedTroop, x, y);
                } else if (cardData.cardType === 'spell') {
                    elixir -= cardData.cost;
                    castSpell('player', selectedTroop, x, y);
                }

                cycleCard(selectedTroop);
                selectedTroop = null;
                const selectedCardEl = cardHandEl.querySelector('.selected');
                if (selectedCardEl) selectedCardEl.classList.remove('selected');
                drawCards();
                updateUI();
            });

            function cycleCard(playedCardId) {
                const playedCardIndex = playerHand.indexOf(playedCardId);
                if (playedCardIndex > -1) {
                    const playedCard = playerHand.splice(playedCardIndex, 1)[0];
                    drawPile.push(playedCard);
                    const nextCard = drawPile.shift();
                    if (nextCard) playerHand.push(nextCard);
                }
            }

            function createTroop(owner, troopId, x, y) {
                const data = CARD_DATA[troopId];
                if (data.spawnIds) {
                     data.spawnIds.forEach(info => {
                        for (let i = 0; i < info.count; i++) createTroop(owner, info.id, x, y);
                     });
                    return;
                }
                if (data.spawnCount > 1) {
                    for (let i = 0; i < data.spawnCount; i++) {
                        const angle = Math.random() * 2 * Math.PI;
                        const radius = Math.random() * (data.spawnRadius || 10);
                        const spawnX = x + (radius / gameBoard.clientWidth * 100) * Math.cos(angle);
                        const spawnY = y + (radius / gameBoard.clientHeight * 100) * Math.sin(angle);
                        createSingleTroop(owner, troopId, spawnX, spawnY);
                    }
                } else {
                    createSingleTroop(owner, troopId, x, y);
                }
            }

            function createSingleTroop(owner, troopId, x, y) {
                const data = CARD_DATA[troopId];
                const troop = {
                    id: nextId++, objType: 'troop', owner, troopId, x, y,
                    hp: data.hp, shieldHp: data.shieldHp || 0, maxHp: data.hp, ...data,
                    target: null, lastAttack: 0, isCharging: false, chargeDistance: 0,
                    frozenUntil: 0, stunnedUntil: 0, rageUntil: 0,
                    originalSpeed: data.speed, originalAttackSpeed: data.attackSpeed,
                    el: document.createElement('div')
                };
                troop.el.className = `troop w-10 h-10`;
                troop.el.style.left = `${x}%`;
                troop.el.style.top = `${y}%`;
                troop.el.style.transform = 'translate(-50%, -50%)';
                troop.el.innerHTML = data.emoji;
                if (owner === 'player') {
                    troop.el.style.backgroundColor = 'rgba(135, 206, 250, 0.7)';
                     troop.el.style.border = '2px solid #4682B4';
                } else {
                     troop.el.style.backgroundColor = 'rgba(240, 128, 128, 0.7)';
                    troop.el.style.border = '2px solid #CD5C5C';
                }
                const healthBar = createHealthBar();
                troop.el.appendChild(healthBar.bar);
                troop.healthBarInner = healthBar.inner;
                gameBoard.appendChild(troop.el);
                gameObjects.push(troop);
            }
            
            function createBuilding(owner, buildingId, x, y) {
                const data = CARD_DATA[buildingId];
                const building = {
                    id: nextId++, objType: 'building', owner, buildingId, x, y,
                    hp: data.hp, maxHp: data.hp, ...data,
                    target: null, lastAttack: 0, lastSpawn: Date.now(),
                    currentDamage: data.damage, currentTargetId: null,
                    frozenUntil: 0, stunnedUntil: 0, rageUntil: 0,
                    speed: 0, originalSpeed: 0, originalAttackSpeed: data.attackSpeed || 0,
                    el: document.createElement('div')
                };
                building.el.className = 'building w-[10%] h-[10%]';
                building.el.style.left = `${x}%`;
                building.el.style.top = `${y}%`;
                building.el.style.transform = 'translate(-50%, -50%)';
                building.el.innerHTML = data.emoji;
                if(owner === 'player') building.el.style.backgroundColor = '#87CEEB';
                if(owner === 'ai') building.el.style.backgroundColor = '#F08080';
                const healthBar = createHealthBar();
                building.el.appendChild(healthBar.bar);
                building.healthBarInner = healthBar.inner;
                gameBoard.appendChild(building.el);
                gameObjects.push(building);
            }

            function castSpell(owner, spellId, x, y) {
                const spellData = CARD_DATA[spellId];
                const opponent = owner === 'player' ? 'ai' : 'player';
                const spellEffectEl = document.createElement('div');
                spellEffectEl.className = 'absolute border-4 rounded-full pointer-events-none';
                spellEffectEl.style.left = `${x}%`;
                spellEffectEl.style.top = `${y}%`;
                spellEffectEl.style.width = `${spellData.radius * 2}%`;
                spellEffectEl.style.height = `${spellData.radius * 2}%`;
                spellEffectEl.style.transform = 'translate(-50%, -50%) scale(0.5)';
                spellEffectEl.style.opacity = '1';
                spellEffectEl.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
                const colors = { fireball: 'rgba(255, 100, 0, 0.8)', arrows: 'rgba(150, 150, 150, 0.8)', zap: 'rgba(100, 100, 255, 0.8)', freeze: 'rgba(173, 216, 230, 0.8)', rage: 'rgba(255, 0, 255, 0.8)', rocket: 'rgba(200, 50, 50, 0.8)', lightning: 'rgba(200, 200, 255, 0.9)' };
                spellEffectEl.style.borderColor = colors[spellId] || 'rgba(255, 255, 255, 0.5)';
                gameBoard.appendChild(spellEffectEl);
                requestAnimationFrame(() => {
                    spellEffectEl.style.transform = 'translate(-50%, -50%) scale(1)';
                    spellEffectEl.style.opacity = '0';
                });
                setTimeout(() => spellEffectEl.remove(), 300);

                if (spellId === 'lightning') {
                    let potentialTargets = gameObjects.filter(obj => obj.owner === opponent && obj.hp > 0 && getDistance({x,y}, obj) <= spellData.radius);
                    potentialTargets.sort((a, b) => b.hp - a.hp);
                    potentialTargets.slice(0, spellData.strikeCount).forEach(target => dealSingleDamage({ damage: spellData.damage, stunDuration: 500 }, target));
                    return;
                }
                if (spellId === 'theLog') {
                    gameObjects.filter(o => o.owner === opponent && o.hp > 0 && o.type === 'ground').forEach(t => {
                        if (Math.abs(t.x - x) < spellData.width / 2 && (owner === 'player' ? (t.y < y) : (t.y > y))) {
                            dealSingleDamage({ damage: spellData.damage }, t);
                        }
                    });
                    return;
                }
                if (spellId === 'rage' || spellId === 'freeze') {
                    const targets = gameObjects.filter(obj => obj.hp > 0 && getDistance({x, y}, obj) <= spellData.radius);
                    targets.forEach(target => {
                        if (spellId === 'rage' && target.owner === owner) {
                            target.rageUntil = Date.now() + spellData.duration;
                            if (target.originalSpeed) target.speed = target.originalSpeed * spellData.speedBoost;
                            if (target.originalAttackSpeed) target.attackSpeed = target.originalAttackSpeed / spellData.attackSpeedBoost;
                        } else if (spellId === 'freeze') {
                            target.frozenUntil = Date.now() + spellData.duration;
                        }
                    });
                    return;
                }
                gameObjects.filter(o => o.owner === opponent && o.hp > 0 && getDistance({x, y}, o) <= spellData.radius)
                    .forEach(t => dealSingleDamage({ damage: spellData.damage, stunDuration: spellData.stunDuration }, t));
            }

            function createProjectile(startObj, endObj, options = {}) {
                const projectileEl = document.createElement('div');
                projectileEl.className = 'projectile';
                if (options.type === 'boulder') {
                    projectileEl.style.backgroundColor = '#8B4513';
                    projectileEl.style.width = '15px';
                    projectileEl.style.height = '15px';
                }
                gameBoard.appendChild(projectileEl);
                const startRect = startObj.el.getBoundingClientRect();
                const endRect = endObj.el.getBoundingClientRect();
                const boardRect = gameBoard.getBoundingClientRect();
                const startX = startRect.left + startRect.width / 2 - boardRect.left;
                const startY = startRect.top + startRect.height / 2 - boardRect.top;
                const endX = endRect.left + endRect.width / 2 - boardRect.left;
                const endY = endRect.top + endRect.height / 2 - boardRect.top;
                projectileEl.style.left = `${startX}px`;
                projectileEl.style.top = `${startY}px`;
                const duration = options.duration || 0.3;
                projectileEl.style.transition = `transform ${duration}s linear`;
                requestAnimationFrame(() => {
                    projectileEl.style.transform = `translate(${endX - startX}px, ${endY - startY}px)`;
                });
                setTimeout(() => {
                    projectileEl.remove();
                    if (startObj.splashDamage) dealSplashDamage(startObj, endObj);
                    else dealSingleDamage(startObj, endObj);
                    if(options.onHit) options.onHit(endObj);
                }, duration * 1000);
            }

            function gameLoop() {
                if(gameTime <= 0) return;
                const objectsToRemove = [];
                gameObjects.forEach(obj => {
                    if (Date.now() < obj.frozenUntil || Date.now() < obj.stunnedUntil) {
                        if (obj.el.style.filter !== 'brightness(0.5)') obj.el.style.filter = 'brightness(0.5)';
                        return;
                    } else if (obj.el.style.filter) obj.el.style.filter = '';

                    if (obj.rageUntil > 0 && Date.now() > obj.rageUntil) {
                        obj.rageUntil = 0;
                        obj.speed = obj.originalSpeed;
                        obj.attackSpeed = obj.originalAttackSpeed;
                    }
                    if (obj.objType === 'building' && obj.lifetime) obj.hp -= obj.maxHp / (obj.lifetime * 30);
                    if (obj.objType === 'building' && obj.givesElixir && Date.now() - obj.lastSpawn > obj.spawnSpeed) {
                        obj.lastSpawn = Date.now();
                        if (obj.owner === 'player' && elixir < maxElixir) elixir++;
                        if (obj.owner === 'ai' && aiElixir < maxElixir) aiElixir++;
                        updateUI();
                    }
                    if ((obj.hp + (obj.shieldHp || 0)) <= 0) {
                        if (obj.dropsRageOnDeath) castSpell(obj.owner, 'rage', obj.x, obj.y);
                        if (obj.spawnOnDeath) {
                            for (let i = 0; i < obj.spawnOnDeath; i++) createTroop(obj.owner, obj.spawnId, obj.x, obj.y);
                        }
                        objectsToRemove.push(obj);
                        return;
                    }
                    if (obj.objType === 'troop') {
                        if (obj.spawnId && (!obj.lastSpawn || Date.now() - obj.lastSpawn > obj.spawnSpeed)) {
                            obj.lastSpawn = Date.now();
                            createTroop(obj.owner, obj.spawnId, obj.x, obj.y);
                        }
                        findTarget(obj);
                        if (obj.target) {
                            if (getDistance(obj, obj.target) <= obj.range * 10) {
                                attack(obj, obj.target);
                                obj.chargeDistance = 0;
                                if (obj.isCharging) {
                                    obj.isCharging = false;
                                    obj.el.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
                                }
                            } else move(obj, obj.target);
                        } else move(obj, {x: obj.x, y: obj.owner === 'player' ? -10 : 110});
                    } else if (obj.objType === 'tower' || (obj.objType === 'building' && obj.damage > 0)) {
                        let canAttack = !(obj.type === 'king' && !obj.isActivated);
                        if (!canAttack) {
                            if (gameObjects.some(e => e.owner !== obj.owner && e.objType === 'troop' && getDistance(obj, e) <= obj.range * 10)) {
                                obj.isActivated = true;
                                canAttack = true;
                            }
                        }
                        if (canAttack) {
                            findTarget(obj);
                            if (obj.target) {
                                if (obj.minRange && getDistance(obj, obj.target) < obj.minRange * 10) {}
                                else attack(obj, obj.target);
                            }
                        }
                    } else if (obj.objType === 'building' && obj.spawnId) {
                        if (Date.now() - obj.lastSpawn > obj.spawnSpeed) {
                            obj.lastSpawn = Date.now();
                            createTroop(obj.owner, obj.spawnId, obj.x, obj.y);
                        }
                    }
                    obj.el.style.left = `${obj.x}%`;
                    obj.el.style.top = `${obj.y}%`;
                    const healthPercentage = (obj.hp / obj.maxHp) * 100;
                    obj.healthBarInner.style.width = `${healthPercentage}%`;
                    obj.healthBarInner.style.backgroundColor = (obj.shieldHp || 0) > 0 ? '#4299E1' : '#4CAF50';
                });
                objectsToRemove.forEach(obj => {
                    obj.el.remove();
                    gameObjects = gameObjects.filter(g => g.id !== obj.id);
                });
                checkGameOver();
                updateTowerCounts();
            }

            function dealSplashDamage(attacker, primaryTarget) {
                 if (!primaryTarget) return;
                gameObjects.filter(o => o.owner !== attacker.owner && o.hp > 0 && getDistance(primaryTarget, o) < attacker.splashRadius)
                    .forEach(enemy => dealSingleDamage(attacker, enemy));
            }
            
            function dealSingleDamage(attacker, target) {
                if (!target) return;
                let damageDealt = attacker.damage;
                if (target.shieldHp > 0) {
                    target.shieldHp -= damageDealt;
                    if (target.shieldHp < 0) {
                        target.hp += target.shieldHp;
                        target.shieldHp = 0;
                    }
                } else target.hp -= damageDealt;
                
                if(attacker.stunDuration) target.stunnedUntil = Date.now() + attacker.stunDuration;
                
                if (attacker.pushback && target.type === 'ground' && target.objType === 'troop') {
                    const angle = Math.atan2(target.y - attacker.y, target.x - attacker.x);
                    target.x += Math.cos(angle) * attacker.pushback * 5;
                    target.y += Math.sin(angle) * attacker.pushback * 5;
                }
                
                target.el.style.filter = 'brightness(2)';
                setTimeout(() => { if (target.el) target.el.style.filter = ''; }, 100);
            }

            function findTarget(attacker) {
                let potentialTargets = gameObjects.filter(obj => 
                    obj.owner !== attacker.owner && (obj.hp + (obj.shieldHp || 0)) > 0 &&
                    (obj.objType === 'troop' || obj.objType === 'tower' || obj.objType === 'building')
                );
                if (attacker.targets === 'ground') potentialTargets = potentialTargets.filter(t => t.type !== 'air');
                else if (attacker.targets === 'air') potentialTargets = potentialTargets.filter(t => t.type === 'air');
                if (attacker.targets === 'buildings') {
                    const buildings = potentialTargets.filter(t => t.objType === 'tower' || t.objType === 'building');
                    if (buildings.length > 0) potentialTargets = buildings;
                }
                attacker.target = potentialTargets.reduce((closest, current) => {
                    const dist = getDistance(attacker, current);
                    return (dist < closest.dist) ? { dist, target: current } : closest;
                }, { dist: Infinity, target: null }).target;
            }
            
            function move(obj, target) {
                 const angle = Math.atan2(target.y - obj.y, target.x - obj.x);
                 const distance = obj.speed * 0.2;
                 obj.x += Math.cos(angle) * distance; 
                 obj.y += Math.sin(angle) * distance;
                 if (obj.canCharge) {
                    obj.chargeDistance += distance;
                    if (obj.chargeDistance > 30 && !obj.isCharging) {
                        obj.isCharging = true;
                        obj.el.style.boxShadow = '0 0 20px rgba(255, 100, 255, 0.9)';
                    }
                 }
            }

            function attack(attacker, target) {
                const now = Date.now();
                const attackSpeed = attacker.attackSpeed || 1500;
                if (now - attacker.lastAttack > attackSpeed) {
                    attacker.lastAttack = now;
                    let finalAttacker = {...attacker};
                    if (attacker.isCharging) finalAttacker.damage *= 2;
                    if (attacker.damageRamp) {
                        if (attacker.currentTargetId === target.id) attacker.currentDamage = Math.min(attacker.maxDamage, attacker.currentDamage * attacker.damageRamp);
                        else attacker.currentDamage = attacker.damage;
                        finalAttacker.damage = attacker.currentDamage;
                        attacker.currentTargetId = target.id;
                    }
                    if (attacker.attackType === 'boomerang') {
                        createProjectile(finalAttacker, target, { onHit: (primaryTarget) => {
                            setTimeout(() => dealSingleDamage(finalAttacker, primaryTarget), 150);
                        }});
                    } else if (attacker.attackType === 'melee-splash') {
                        gameObjects.filter(o => o.owner !== attacker.owner && o.hp > 0 && getDistance(finalAttacker, o) <= finalAttacker.range * 10)
                            .forEach(enemy => dealSingleDamage(finalAttacker, enemy));
                    } else if (attacker.range > 2.0) {
                        let pOptions = {};
                        if (attacker.name === 'Mortar' || attacker.name === 'Bowler') pOptions.duration = 1.0;
                        if (attacker.name === 'Bowler') pOptions.type = 'boulder';
                        createProjectile(finalAttacker, target, pOptions);
                    } else {
                        dealSingleDamage(finalAttacker, target);
                    }
                }
            }

            function getDistance(obj1, obj2) {
                if (!obj1 || !obj2) return Infinity;
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            function generateElixir() {
                 if (gameTime <= 0) return;
                 if (elixir < maxElixir) elixir++;
                 if (aiElixir < maxElixir) aiElixir++;
                 updateUI();
            }
            
            function updateTimer() {
                if (gameTime > 0) {
                    gameTime--;
                    timerEl.textContent = gameTime;
                    if (gameTime === 60) {
                        clearInterval(elixirInterval);
                        elixirInterval = setInterval(generateElixir, 1000);
                        timerEl.classList.add('text-purple-400', 'font-extrabold', 'animate-pulse');
                    }
                } else {
                    clearInterval(timerInterval);
                    endGame();
                }
            }
            
            function aiLogic() {
                if(gameTime <= 0) return;
                const placeableCards = Object.keys(CARD_DATA).filter(id => CARD_DATA[id].cost <= aiElixir);
                if (placeableCards.length === 0) return;
                const randomCardId = placeableCards[Math.floor(Math.random() * placeableCards.length)];
                const cardData = CARD_DATA[randomCardId];
                if (Math.random() < (aiElixir > 7 ? 0.8 : 0.4)) { 
                    aiElixir -= cardData.cost;
                    if (cardData.cardType === 'troop' || cardData.cardType === 'building') {
                        let x = Math.random() * 80 + 10;
                        let y = Math.random() * 40 + 5;
                        if (cardData.canPlaceAnywhere) y = Math.random() * 40 + 55;
                        if (cardData.name === 'X-Bow' || cardData.name === 'Mortar') {
                            y = 35;
                            x = Math.random() > 0.5 ? 25 : 75;
                        }
                        if (cardData.cardType === 'troop') createTroop('ai', randomCardId, x, y);
                        else createBuilding('ai', randomCardId, x, y);
                    } else if (cardData.cardType === 'spell') {
                        const playerUnits = gameObjects.filter(o => o.owner === 'player' && o.y < 50);
                        if (playerUnits.length > 0) {
                            const target = playerUnits[Math.floor(Math.random() * playerUnits.length)];
                            castSpell('ai', randomCardId, target.x, target.y);
                        } else {
                            const playerTowers = gameObjects.filter(o => o.owner === 'player' && o.objType === 'tower');
                            if (playerTowers.length > 0) {
                                const target = playerTowers[Math.floor(Math.random() * playerTowers.length)];
                                castSpell('ai', randomCardId, target.x, target.y);
                            }
                        }
                    }
                }
            }

            function updateTowerCounts() {
                playerTowersEl.textContent = gameObjects.filter(o => o.objType === 'tower' && o.owner === 'player').length;
                aiTowersEl.textContent = gameObjects.filter(o => o.objType === 'tower' && o.owner === 'ai').length;
            }

            function checkGameOver() {
                const playerKing = gameObjects.find(o => o.owner === 'player' && o.type === 'king');
                const aiKing = gameObjects.find(o => o.owner === 'ai' && o.type === 'king');
                if (!playerKing) endGame('AI Wins!');
                else if (!aiKing) endGame('You Win!');
            }
            
            function endGame(result) {
                clearInterval(gameLoopInterval);
                clearInterval(timerInterval);
                let title = '', text = '';
                if (result) {
                     title = result;
                     text = "The King Tower has been destroyed!";
                } else {
                    const pTowers = gameObjects.filter(o => o.objType === 'tower' && o.owner === 'player').length;
                    const aTowers = gameObjects.filter(o => o.objType === 'tower' && o.owner === 'ai').length;
                    if(pTowers > aTowers) {
                        title = 'You Win on Points!';
                        text = `You had ${pTowers} towers remaining to the AI's ${aTowers}.`;
                    } else if (aTowers > pTowers) {
                         title = 'AI Wins on Points!';
                         text = `The AI had ${aTowers} towers remaining to your ${pTowers}.`;
                    } else {
                        title = 'It\'s a Draw!';
                        text = 'Both sides had the same number of towers remaining.';
                    }
                }
                messageTitle.textContent = title;
                messageText.textContent = text;
                messageModal.classList.remove('hidden');
            }
            
            restartButton.addEventListener('click', initGame);
            startBattleButton.addEventListener('click', startGame);

            function updateUI() {
                elixirCountEl.textContent = Math.floor(elixir);
                elixirBarFill.style.width = `${(elixir / maxElixir) * 100}%`;
                updateCardAvailability();
            }

            initGame();
        });
    </script>
</body>
</html>
